#### 泛型的限定

- <T extends Comparable>约定 T 必须是 Comparable 的子类
- **extends 固定**，后面可以多个，**以&拼接**，如<T extends Comparable & Serializable>
- extends 限定**可以有多个接口，但只能一个类，且类必须排在第一位**
- **逗号隔参数**，<T extends Fils & Cloneable, U extends Serializable>

```java

public static <T extends Comparable> T getMin(T... a) {
    if (null == a || a.length <= 0) {
        return null;
    }
    T min = a[0];
    for (int i = 0; i < a.length; i++) {
        if (min.compareTo(a[i]) > 0) {
            min = a[i];
        }
    }
    return min;
}
```

#### 泛型类之间的继承
- Pair<S> 和 Pair<T> 没有任何关系，无论S和T之间是什么关系

```java
Pair<Apple> apples = new Pair<>(new Apple(3), new Apple(4));
Pair<Fruit> = fruits = apples;
fruits.setFirst(new Orange(5)); 

```

- 泛型类可以扩展或实现其它的类，如 ArrayList<T>，实现List<T>


#### 泛型通配符类型

- 上限界定符，Pair<? extends S>
- Pair 能接收的参数类型，是 S 自身或者子类
- Pair<? extends Fruit>代表 Pair<Fruit>，Pair<Apple>，Pair<Orange>等

- 下限界定符，Pair<? super S>
- Pair 能接收的参数类型，是 S 自身或者超类
- Pair<? extends Fruit>代表 Pair<Object>，Pair<Fruit>，Pair<Apple>等

```java
// Pair<Apple>，Pair<Orange>皆可
// Fruit的子类都有getSize()方法
public void printFruits(Pair<? extends Fruit> fruits) {
    Fruit first = fruits.getFirst();
    Fruit second = fruits.getSecond();

    System.out.printLn("The sizes of fruits are" + first.getSize() + "," + second.getSize());
}

```

#### 泛型 PECS 原则

- Producer Extends, Consumer Super
- 要从泛型类读取类型 T 的数据，并且不能写入，可以使用 ? extends 通配符；（Producer Extends，泛型类是生产者，往外输出东西）
- 如果要向泛型类写入类型 T 的数据，并且不需要读取，可以使用 ? super 通配符；（Consumer Super，泛型类是消费者，往内增加东西）
- 如果既要写入又想读出，那就不要用通配符
