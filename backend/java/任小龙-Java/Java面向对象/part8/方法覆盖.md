##### 方法覆盖 

> 场景：
>
> 子类拓展了父类，可以获得父类的部分方法和成员变量，可是当父类的某个方法
>
> 不适合子类本身特征的时候，此时怎么办？
>
> 如企鹅和鸵鸟是鸟类中的一个特殊品种，所以企鹅和鸵鸟是鸟类的一个子类，但是
>
> 鸟类有飞翔的功能，而对应的企鹅和鸵鸟，飞翔的行为显然不适合它。
>
> 此时该怎么办？



```java
//鸟类
class Bird {
    public void fly() {
        System.out.println("我在仰望，自由飞翔");
    }
}
//企鹅
class Penguin extends Bird {
    //方法覆盖
    //方法重写
    //重写定义了fly方法
    @Override //判断当前子类的方法是否是
    public void fly() {
        System.out.println("企鹅飞吧");
    }
}

public class HelloWord {
    public static void main(String[] args) {
        //创建一个企鹅对象，并调用其飞翔的方法
        Penguin p = new Penguin();
        //先从子类中去寻找fly方法，如果找到则执行
        //如果找不到，继续去父类中查找
        p.fly();
    }
}
```

##### 方法覆盖的原则（一同两小一大）

一同

1. 实例方法签名必须相同，方法名 + 方法的参数列表

两小

1. 子类方法的返回值类型和父类方法的返回值类型相同或者是其子类
2. 子类方法中声明抛出的异常类型和父类方法声明抛出的异常类型相同

一大

1. 子类的方法访问权限比父类方法访问权限更大或相等

> 判断是否是覆写方法的必杀技
>
> @Override标签
>
> 若方法是覆写方法，在方法前或上粘上该标签
>
> 编译通过，否则编译出错
>
> 只有方法有覆盖的概念，字段没有覆盖

private修饰的方法，不能被子类所继承，也就是说不存在覆写的概念

##### 方法覆盖解决了什么问题？

当父类的某一个行为不符合子类具体的特征时，此时子类需要重新定义父类的方法