<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalabel=no,viewport-fit=cover"
    />
    <meta content=" no-cache,must-revalidate" http-equiv="Cache-Control" />
    <meta content="no-cache" http-equiv="pragma" />
    <!--清除浏览器缓存-->
    <meta content="0" http-equiv="expires" />
    <meta content="telephone=no, address=no" name="format-detection" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>D3js是什么</title>
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background-color: #fff;
      }
      #app {
        height: 100%;
      }
      svg:not(root) {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="seeTree-page">
        <div id="treeRoot"></div>
      </div>
    </div>
  </body>
  <script src="https://res2.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script>
    const treeData = { r: {}, l: {} };
    // const treeData = {
    //   r: {
    //     name: '改造成本',
    //     children: [
    //       {
    //         name: '征地规费',
    //         children: [
    //           { name: '中国资产管理行业概览', value: '' },
    //           {
    //             name: '关于调整森林植被恢复费征收标准引导节约集约利用林地的通知（财税〔2015〕122号）',
    //             value: ''
    //           }
    //         ]
    //       },
    //       {
    //         name: '征地补偿费',
    //         children: [
    //           { name: '股票发行' },
    //           { name: '债券发行' },
    //           {
    //             name: '资产证券化',
    //             value: '',
    //             children: [
    //               {
    //                 name: '债券发行与承销',
    //                 children: [
    //                   {
    //                     name: '债券发行与承销'
    //                   },
    //                   {
    //                     name: '债券市场概况',
    //                     children: [
    //                       {
    //                         name: '债券市场概况'
    //                       },
    //                       {
    //                         name: '债券融资在企业融资中的角色'
    //                       }
    //                     ]
    //                   },
    //                   {
    //                     name: '主要债券融资工具的类型与特点'
    //                   },
    //                   {
    //                     name: '公司债券发行基础'
    //                   }
    //                 ]
    //               }
    //             ]
    //           }
    //         ]
    //       },
    //       {
    //         name: '指标规模费',
    //         children: [
    //           {
    //             name: '地产金融',
    //             value: '',
    //             children: [
    //               { name: '地产金融基础', value: '' },
    //               { name: '地产非标融资实务之产品设计', value: '' }
    //             ]
    //           },
    //           {
    //             name: '政信城投',
    //             value: '',
    //             children: [
    //               { name: '融资平台的前世今生与未来', value: '' },
    //               { name: '金融机构政信城投业务模式及风控要点', value: '' }
    //             ]
    //           }
    //         ]
    //       },
    //       {
    //         name: '造价标准'
    //       },
    //       {
    //         name: '整合成本'
    //       },
    //       {
    //         name: '专项成本',
    //         children: [
    //           {
    //             name: '番禺区旧村庄全面改造专项成本审查方案（2019年11月发布）'
    //           }
    //         ]
    //       },
    //       {
    //         name: '地价与出让金',
    //         children: [
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           },
    //           {
    //             name: '广州市国土资源和规划委员会关于印发明确我市国有建设用地使用权出让金计收标准的通知（穗国土规划规字[2018〕2号)'
    //           }
    //         ]
    //       }
    //     ]
    //   },
    //   l: {
    //     name: '市级层面的文件',
    //     children: [
    //       {
    //         name: '市级层面的文件',
    //         children: [
    //           {
    //             name: '黄埔区',
    //             value: '',
    //             children: [
    //               {
    //                 name: '广州开发区城市更新局关于印发《广州市黄埔区 广州开发区（九龙片区除外）旧村改造补偿安置方案（模板）》和《广州市黄埔区九龙片区旧村改造补偿安置方案（模板）》的通知（穗开更新〔2019〕49号）'
    //               },
    //               {
    //                 name: '黄埔区九龙片区旧村现状建筑测量和复建安置计算工作指引（穗开更新规字〔2019〕1 号）'
    //               },
    //               {
    //                 name: '广州开发区城市更新局关于发布广州市黄埔区、广州开发区2020年城市更新区片土地市场评估价的公告'
    //               },
    //               {
    //                 name: '广州市黄埔区广州开发区2021年城市更新区片土地市场评估价'
    //               }
    //             ]
    //           },
    //           { name: '花都区', value: '' },
    //           { name: '增城区', value: '' },
    //           { name: '南沙区', value: '' },
    //           { name: '增城区', value: '' },
    //           { name: '番禺区', value: '' },
    //           {
    //             name: '从化区',
    //             value: '',
    //             children: [
    //               {
    //                 name: '广州市规划和自然资源局从化区分局关于印发《广州市从化区旧村庄全面改造类项目复建总量核算的技术规范》的通知（穗规划资源从〔2021〕2号）'
    //               }
    //             ]
    //           },
    //           { name: '荔湾区', value: '' },
    //           { name: '海珠区', value: '' },
    //           { name: '越秀区', value: '' },
    //           { name: '天河区', value: '' },
    //           { name: '白云区', value: '' }
    //         ]
    //       },
    //       {
    //         name: '改造成本审查（审核）类文件',
    //         value: '[董事]'
    //       }
    //     ]
    //   }
    // };

    let container = null; //容器svg>g
    let duration = 550; //动画持续时间
    let scaleRange = [0.2, 4]; //container缩放范围
    let direction = ['r', 'l']; //分为左右2个方向
    let centralPoint = [0, 0]; //画布中心点坐标x,y
    let root = { r: {} }; //左右2块数据源
    let rootNodeLength = 0; //根节点名称长度
    let rootName = ['改造成本']; //根节点名称
    let textSpace = 15; //多行文字间距
    let themeColor = '#2196F3'; //主色
    let nodeSize = [60, 150]; //节点间距(高/水平)
    let fontSize = 12; //字体大小，也是单字所占宽高
    let rectMinWidth = 50; //节点方框默认最小，
    let textPadding = 5; //文字与方框间距,注：固定值5
    let circleR = 5; //圆圈半径
    let margin1 = { top: 50, right: 20, bottom: -20, left: 0 };

    getData();
    function getData() {
      fetch(`http://localhost:8039/app/policy/point`, {
        credentials: 'same-origin',
        mode: 'cors',
        method: 'post',
        header: {
          'content-type': 'application/json' // 默认值
        }
      })
        .then((response) => response.json())
        .then((json) => {
          let data = json.data;
          // console.log(data[0]);
          treeData['l'] = data[1];
          treeData['r'] = data[0];
          treeInit();
          // function mapTree(org) {
          //   const hasChildren = Array.isArray(org.children) && org.children.length > 0;

          //   return {
          //     id: org.id,
          //     name: org.name,
          //     children: hasChildren ? org.children.map((i) => mapTree(i)) : []
          //   };
          // }
          // let arr = data.map((org) => mapTree(org));
          // console.log(arr);
        });
    }
    function treeInit() {
      const margin = { top: 0, right: 0, bottom: 0, left: 0 };
      const treeWidth = document.body.clientWidth - margin.left - margin.right; //tree容器宽
      const treeHeight = document.body.clientHeight - margin.top - margin.bottom; //tree容器高
      const centralY = treeWidth / 2 + margin.left;
      const centralX = treeHeight / 2 + margin.top;
      centralPoint = [centralX, centralY]; //中心点坐标

      //根节点字符所占宽度
      rootNodeLength = rootName[0].length * fontSize + 50;

      let svg = d3
        .select('#treeRoot')
        .append('svg')
        .attr('class', 'tree-svg')
        .attr('xmlns', 'http://www.w3.org/2000/svg')
        .attr('width', treeWidth)
        .attr('height', treeHeight)
        .attr('font-size', fontSize)
        .attr('fill', '#555');

      container = svg
        .append('g')
        .attr('class', 'container1')
        .attr('transform', `translate(${margin1.left}, ${margin1.top}), scale(0.8)`);

      drawRoot();

      const zoom = d3.zoom().scaleExtent(scaleRange).on('zoom', zoomFn);

      //动画持续时间
      container.transition().duration(duration).call(zoom.transform, d3.zoomIdentity);
      svg.call(zoom);

      dealData();
    }
    function uuid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
      }

      return (
        s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4()
      );
    }
    function zoomFn() {
      const zoom = d3.event.transform;
      return container.attr('transform', zoom);
    }
    function dealData() {
      direction.forEach((item) => {
        root[item] = d3.hierarchy(treeData[item]);
        root[item].x0 = centralPoint[0]; //根节点x坐标
        root[item].y0 = centralPoint[1]; //根节点Y坐标
        root[item].descendants().forEach((d) => {
          d._children = d.children; //添加_children属性，用于实现点击收缩及展开功能
          d.id = item + uuid(); //绑定唯一标识ID
        });
        update(root[item], item);
      });
    }
    function drawRoot() {
      const title = container
        .append('g')
        .attr('id', 'rootTitle')
        .attr('transform', `translate(${centralPoint[1]},${centralPoint[0]})`);
      title
        .append('svg:rect')
        .attr('class', 'rootTitle')
        .attr('y', 0)
        .attr('x', -rootNodeLength / 2)
        .attr('width', rootNodeLength)
        .attr('height', 0)
        .attr('rx', 5) //圆角
        .style('fill', themeColor);
      rootName.forEach((name, index) => {
        title
          .append('text')
          .attr('fill', 'white')
          .attr('y', function () {
            return 5;
          })
          .attr('text-anchor', 'middle')
          .style('font-size', function () {
            if (index == 1) {
              return '10px';
            } else {
              return '15px';
            }
          })
          .text(name);

        let lineHeight = (index + 3) * textSpace;
        d3.select('#rootTitle rect')
          .attr('height', lineHeight)
          .attr('y', -lineHeight / 2);
      });
    }
    function update(source, direction) {
      const dirRight = direction === 'r' ? 1 : -1; //方向为右/左
      const className = `${direction}gNode`;
      // const tree = treeMap(root[direction]);
      let treeMap = d3
        .tree()
        .nodeSize(nodeSize)
        .separation((a, b) => {
          let result = a.parent === b.parent && !a.children && !b.children ? 1 : 2;
          return result;
        });
      let tree = treeMap(root[direction]);
      const nodes = tree.descendants(); //返回后代节点数组，第一个节点为自身，然后依次为所有子节点的拓扑排序
      const links = tree.links(); //返回当前 node 的 links 数组, 其中每个 link 定义了 source父节点, target 子节点属性。
      nodes.forEach((d) => {
        //左右2部分，设置以中心点为圆点(默认左上角为远点)
        d.y = dirRight * (d.y + rootNodeLength / 2) + centralPoint[1];
        d.x = d.x + centralPoint[0];
      });
      //根据class名称获取左或者右的g节点，达到分块更新
      const node = container.selectAll(`g.${className}`).data(nodes, (d) => d.id);

      //新增节点，tree会根据数据内的children扩展相关节点
      const nodeEnter = node
        .enter()
        .append('g')
        .attr('id', (d) => `g${d.id}`)
        .attr('class', className)
        .attr('transform', (d) => `translate(${source.y0},${source.x0})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0)
        .on('click', (d) => {
          d.depth !== 0 && clickNode(d, direction); //根节点不执行点击事件
        });

      nodeEnter.each((d) => {
        if (d.depth > 0) {
          //非根节点且无子节点
          drawText(`g${d.id}`, dirRight); //画文本

          if (d.data.value) {
            drawTsText(`g${d.id}`); //画子文本
          }
          drawRect(`g${d.id}`, dirRight); //画方框
          // drawFilter(`g${d.id}`);//画阴影
          // d3.select(`#g${d.id} rect`).attr('stroke-width',15).attr('filter',`url(#fg${d.id})`);//给rect绑定阴影
        }
        if (d.depth > 0 && d._children) {
          //非根节点且有子节点
          const width = Math.min(d.data.name.length * 14, rectMinWidth);
          let right = dirRight > 0; //右为1，左为-1
          let xDistance = right ? width : -width;
          d3.select(`#g${d.id} rect`)
            .attr('width', width)
            .attr('x', right ? 0 : -width)
            .style('fill', '#ffffff')
            .style('stroke', '#ffffff'); //修改rect属性

          d3.select(`#g${d.id} text`)
            .attr('text-anchor', right ? 'end' : 'start')
            .attr('x', right ? xDistance - circleR : xDistance + circleR); //修改文本属性
          drawCircle(`g${d.id}`); //画圆圈
          d3.select(`#g${d.id} g`).attr('transform', `translate(${xDistance},0)`); //修改圆圈属性
        }
      });

      // 更新节点：节点enter和exit时都会触发tree更新
      const nodeUpdate = node
        .merge(nodeEnter)
        .transition()
        .duration(duration)
        .attr(
          'transform',
          (d) => `translate(${d.y - (dirRight * rectMinWidth) / 2},${d.x})`
        )
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1);

      // 移除节点:tree移除掉数据内不包含的节点(即，children = false)
      const nodeExit = node
        .exit()
        .transition()
        .duration(duration)
        .remove()
        .attr('transform', (d) => `translate(${source.y},${source.x})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0);

      // Update the links 根据 className来实现分块更新
      const link = container
        .selectAll(`path.${className}`)
        .data(links, (d) => d.target.id);

      // Enter any new links at the parent's previous position.
      //insert是在g标签前面插入，防止连接线挡住G节点内容
      const linkEnter = link
        .enter()
        .insert('path', 'g')
        .attr('class', className)
        .attr('d', (d) => {
          const o = { x: source.x0, y: source.y0 };
          return diagonal({ source: o, target: o });
        })
        .attr('fill', 'none')
        .attr('stroke-width', 1)
        .attr('stroke', '#d8d8d8');

      // Transition links to their new position.
      link.merge(linkEnter).transition().duration(duration).attr('d', diagonal);

      // Transition exiting nodes to the parent's new position.
      link
        .exit()
        .transition()
        .duration(duration)
        .remove()
        .attr('d', (d) => {
          const o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        });

      // Stash the old positions for transition.
      root[direction].eachBefore((d) => {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }
    //画连接线
    function diagonal({ source, target }) {
      let s = source,
        d = target;
      return `M ${s.y} ${s.x} L ${(s.y + d.y) / 2} ${s.x}, L ${(s.y + d.y) / 2} ${
        d.x
      }, ${d.y} ${d.x}`;
    }
    //画文本
    function drawText(id, dirRight) {
      dirRight = dirRight > 0; //右为1，左为-1
      return d3
        .select(`#${id}`)
        .append('text')
        .attr('y', textPadding)
        .attr('x', (d) => (dirRight ? textPadding : -textPadding))
        .attr('text-anchor', dirRight ? 'start' : 'end')
        .style('font-size', fontSize)
        .text((d) => d.data.name);
    }
    //画子文本
    function drawTsText(id) {
      return d3
        .select(`#${id} text`)
        .append('tspan')
        .attr('fill', (d) => getTsTextColor(d.parent.data.name))
        .text((d) => d.data.value);
    }
    //画方框阴影
    function drawFilter(id) {
      return d3
        .select(`#${id}`)
        .insert('defs', 'rect')
        .append('filter')
        .attr('id', `f${id}`)
        .attr('x', 0)
        .attr('y', 0)
        .append('feGaussianBlur')
        .attr('in', 'SourceGraphic')
        .attr('stdDeviation', '5');
    }
    //画方框
    function drawRect(id, dirRight) {
      let realw = document.getElementById(id).getBBox().width + 10; //获取g实际宽度后，设置rect宽度
      return d3
        .select(`#${id}`)
        .insert('rect', 'text')
        .attr('x', dirRight > 0 ? 0 : -realw)
        .attr('y', -textSpace + textPadding)
        .attr('width', realw)
        .attr('height', textSpace + textPadding)
        .attr('rx', 2) //圆角
        .style('stroke', (d) => getRectStorke(d.parent.data.name))
        .style('fill', '#ffffff');
    }
    //画circle
    function drawCircle(id) {
      let gMark = d3
        .select(`#${id}`)
        .append('g')
        .attr('class', 'node-circle')
        .attr('stroke', '#ffa500')
        .attr('stroke-width', 1);

      gMark
        .append('circle')
        .attr('fill', 'none')
        .attr('r', (d) => (d.depth === 0 ? 0 : circleR)) //根节点不设置圆圈
        .attr('fill', '#ffffff');
      let padding = circleR - 2;
      gMark.append('path').attr('d', `m -${padding} 0 l ${2 * padding} 0`); //横线

      gMark
        .append('path') //竖线，根据展开/收缩动态控制显示
        .attr('d', `m 0 -${padding} l 0 ${2 * padding}`)
        .attr('stroke-width', 0)
        .attr('class', 'node-circle-vertical');
      return gMark;
    }
    //点击某个节点
    function clickNode(d, direction) {
      if (!d._children && !d.children) {
        console.log(d);
        console.log(direction);
        //无子节点
        return;
      }
      console.log(d);
      console.log(direction);
      //根据当前节点是否有children来判断是展开还是收缩，true收缩，false展开
      //tree会根据节点内是否有children来向下扩展
      d.children = d.children ? null : d._children;
      d3.select(`#g${d.id} .node-circle .node-circle-vertical`)
        .transition()
        .duration(duration)
        .attr('stroke-width', d.children ? 0 : 1); //控制节点伸缩时的标识圆圈
      update(d, direction);
    }
    function getTsTextColor(name) {
      switch (name) {
        case '股东':
          return 'darkgray';
        case '供应商':
          return '#FF9800';
        case '合伙人':
          return 'green';
        default:
          return 'black';
      }
    }
    function getRectStorke(name) {
      switch (name) {
        case '股东':
          return 'green';
        case '供应商':
          return 'skyblue';
        case '合伙人':
          return '#FF9800';
        default:
          return 'gray';
      }
    }
  </script>
</html>
