<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalabel=no,viewport-fit=cover"
    />
    <meta content=" no-cache,must-revalidate" http-equiv="Cache-Control" />
    <meta content="no-cache" http-equiv="pragma" />
    <!--清除浏览器缓存-->
    <meta content="0" http-equiv="expires" />
    <meta content="telephone=no, address=no" name="format-detection" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <title>政策关系图谱</title>
    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    <script>
      // VConsole 默认会挂载到 `window.VConsole` 上
      var vConsole = new window.VConsole();
    </script>
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background-color: #fff;
      }
      #app {
        height: 100%;
      }
      svg:not(root) {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="seeTree-page">
        <div id="treeRoot"></div>
      </div>
    </div>
  </body>
  <script src="https://res2.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script>
    let miniprogram = false;
    const treeData = { r: {}, l: {} };
    let container = null; // 容器svg>g
    let duration = 550; // 动画持续时间
    let scaleRange = [0.2, 2]; // container缩放范围
    let direction = ['r', 'l']; // 分为左右2个方向
    let centralPoint = [0, 0]; // 画布中心点坐标x,y
    let root = { r: {}, l: {} }; // 左右2块数据源
    let rootNodeLength = 0; // 根节点名称长度
    let rootName = []; // 根节点名称
    let textSpace = 15; // 多行文字间距
    let themeColor = '#409eff'; //主色
    let nodeSize = [50, 150]; // 节点间距(高/水平)
    let fontSize = 13; // 字体大小，也是单字所占宽高
    let rectMinWidth = 50; // 节点方框默认最小，
    let textPadding = 5; // 文字与方框间距,注：固定值5
    let circleR = 5; // 圆圈半径
    let margin1 = { top: 50, right: 20, bottom: -20, left: 0 };
    ready();
    getData();
    // 判断是否是小程序环境
    function ready() {
      console.log(window.__wxjs_environment === 'miniprogram'); // true
      if (window.__wxjs_environment === 'miniprogram') {
        miniprogram = true;
      }
    }
    if (!window.WeixinJSBridge || !WeixinJSBridge.invoke) {
      document.addEventListener('WeixinJSBridgeReady', ready, false);
    } else {
      ready();
    }
    // let arr = data.map((org) => mapTree(org));
    function mapTree(org) {
      const hasChildren = Array.isArray(org.children) && org.children.length > 0;

      return {
        id: org.id,
        name: org.name,
        children: hasChildren ? org.children.map((i) => mapTree(i)) : []
      };
    }
    // 跳转小程序页面
    function navigateTo(id) {
      miniprogram &&
        wx.miniProgram.navigateTo({ url: `/pages/policy/show/index?id=${id}` });
    }
    // 获取数据
    function getData() {
      let url = false ? 'https://api.xingguangcheng.top/app/policy/point' : 'http://localhost:8039/app/policy/point';
      fetch(url, {
        credentials: 'same-origin',
        mode: 'cors',
        method: 'post',
        header: {
          'content-type': 'application/json' // 默认值
        }
      })
        .then((response) => response.json())
        .then((json) => {
          let data = json.data;
          if (data.length) {
            let name = data[0].name;
            let children = data[0].children;
            let len = children.length;
            let n = parseInt(len / 2);
            let l = children.slice(0, n);
            let r = children.slice(n, len);
            let treeL = { name, children: [...l] };
            let treeR = { name, children: [...r] };
            rootName[0] = name;
            treeData['r'] = treeL;
            treeData['l'] = treeR;
            treeInit();
          }
        });
    }
    function treeInit() {
      const margin = { top: 0, right: 0, bottom: 0, left: 0 };
      const treeWidth = document.body.clientWidth - margin.left - margin.right; //tree容器宽
      const treeHeight = document.body.clientHeight - margin.top - margin.bottom; //tree容器高
      const centralY = treeWidth / 2 + margin.left;
      const centralX = treeHeight / 2 + margin.top;
      centralPoint = [centralX, centralY]; //中心点坐标

      //根节点字符所占宽度
      rootNodeLength = rootName[0].length * fontSize + 50;

      let svg = d3
        .select('#treeRoot')
        .append('svg')
        .attr('class', 'tree-svg')
        .attr('xmlns', 'http://www.w3.org/2000/svg')
        .attr('width', treeWidth)
        .attr('height', treeHeight)
        .attr('font-size', fontSize)
        .attr('fill', '#555');

      container = svg
        .append('g')
        .attr('class', 'container1')
        .attr('transform', `translate(${margin1.left}, ${margin1.top}), scale(1)`);

      drawRoot();

      const zoom = d3.zoom().scaleExtent(scaleRange).on('zoom', zoomFn);

      //动画持续时间
      container.transition().duration(duration).call(zoom.transform, d3.zoomIdentity);
      svg.call(zoom);

      dealData();
    }
    function uuid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
      }

      return (
        s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4()
      );
    }
    function zoomFn() {
      const zoom = d3.event.transform;
      return container.attr('transform', zoom);
    }
    function dealData() {
      direction.forEach((item) => {
        root[item] = d3.hierarchy(treeData[item]);
        root[item].x0 = centralPoint[0]; //根节点x坐标
        root[item].y0 = centralPoint[1]; //根节点Y坐标
        root[item].descendants().forEach((d) => {
          d._children = d.children; //添加_children属性，用于实现点击收缩及展开功能
          d.id = item + uuid(); //绑定唯一标识ID
        });
        update(root[item], item);
      });
    }
    function drawRoot() {
      const title = container
        .append('g')
        .attr('id', 'rootTitle')
        .attr('transform', `translate(${centralPoint[1]},${centralPoint[0]})`);
      title
        .append('svg:rect')
        .attr('class', 'rootTitle')
        .attr('y', 0)
        .attr('x', -rootNodeLength / 2)
        .attr('width', rootNodeLength)
        .attr('height', 0)
        .attr('rx', 5) //圆角
        .style('fill', themeColor);
      rootName.forEach((name, index) => {
        title
          .append('text')
          .attr('fill', 'white')
          .attr('y', function () {
            return 5;
          })
          .attr('text-anchor', 'middle')
          .style('font-size', function () {
            if (index == 1) {
              return '10px';
            } else {
              return '15px';
            }
          })
          .text(name);

        let lineHeight = (index + 3) * textSpace;
        d3.select('#rootTitle rect')
          .attr('height', lineHeight)
          .attr('y', -lineHeight / 2);
      });
    }
    function update(source, direction) {
      const dirRight = direction === 'r' ? 1 : -1; //方向为右/左
      const className = `${direction}gNode`;
      // const tree = treeMap(root[direction]);
      let treeMap = d3
        .tree()
        .nodeSize(nodeSize)
        .separation((a, b) => {
          let result = a.parent === b.parent && !a.children && !b.children ? 1 : 2;
          return result;
        });
      let tree = treeMap(root[direction]);
      const nodes = tree.descendants(); //返回后代节点数组，第一个节点为自身，然后依次为所有子节点的拓扑排序
      const links = tree.links(); //返回当前 node 的 links 数组, 其中每个 link 定义了 source父节点, target 子节点属性。
      nodes.forEach((d) => {
        //左右2部分，设置以中心点为圆点(默认左上角为远点)
        d.y = dirRight * (d.y + rootNodeLength / 2) + centralPoint[1];
        d.x = d.x + centralPoint[0];
      });
      //根据class名称获取左或者右的g节点，达到分块更新
      const node = container.selectAll(`g.${className}`).data(nodes, (d) => d.id);

      //新增节点，tree会根据数据内的children扩展相关节点
      const nodeEnter = node
        .enter()
        .append('g')
        .attr('id', (d) => `g${d.id}`)
        .attr('class', className)
        .attr('transform', (d) => `translate(${source.y0},${source.x0})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0)
        .on('click', (d) => {
          d.depth !== 0 && clickNode(d, direction); //根节点不执行点击事件
        });

      nodeEnter.each((d) => {
        if (d.depth > 0) {
          //非根节点且无子节点
          drawText(`g${d.id}`, dirRight); //画文本

          if (d.data.value) {
            drawTsText(`g${d.id}`); //画子文本
          }
          drawRect(`g${d.id}`, dirRight); //画方框
          // drawFilter(`g${d.id}`);//画阴影
          // d3.select(`#g${d.id} rect`).attr('stroke-width',15).attr('filter',`url(#fg${d.id})`);//给rect绑定阴影
        }
        if (d.depth > 0 && d._children) {
          //非根节点且有子节点
          const width = Math.min(d.data.name.length * 14, rectMinWidth);
          let right = dirRight > 0; //右为1，左为-1
          let xDistance = right ? width : -width;
          d3.select(`#g${d.id} rect`)
            .attr('width', width)
            .attr('x', right ? 0 : -width)
            .style('fill', '#ffffff')
            .style('stroke', '#ffffff'); //修改rect属性

          d3.select(`#g${d.id} text`)
            .attr('text-anchor', right ? 'end' : 'start')
            .attr('x', right ? xDistance - circleR : xDistance + circleR); //修改文本属性
          drawCircle(`g${d.id}`); //画圆圈
          d3.select(`#g${d.id} g`).attr('transform', `translate(${xDistance},0)`); //修改圆圈属性
        }
      });

      // 更新节点：节点enter和exit时都会触发tree更新
      const nodeUpdate = node
        .merge(nodeEnter)
        .transition()
        .duration(duration)
        .attr(
          'transform',
          (d) => `translate(${d.y - (dirRight * rectMinWidth) / 2},${d.x})`
        )
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1);

      // 移除节点:tree移除掉数据内不包含的节点(即，children = false)
      const nodeExit = node
        .exit()
        .transition()
        .duration(duration)
        .remove()
        .attr('transform', (d) => `translate(${source.y},${source.x})`)
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0);

      // Update the links 根据 className来实现分块更新
      const link = container
        .selectAll(`path.${className}`)
        .data(links, (d) => d.target.id);

      // Enter any new links at the parent's previous position.
      //insert是在g标签前面插入，防止连接线挡住G节点内容
      const linkEnter = link
        .enter()
        .insert('path', 'g')
        .attr('class', className)
        .attr('d', (d) => {
          const o = { x: source.x0, y: source.y0 };
          return diagonal({ source: o, target: o });
        })
        .attr('fill', 'none')
        .attr('stroke-width', 1)
        .attr('stroke', '#EBEEF5');

      // Transition links to their new position.
      link.merge(linkEnter).transition().duration(duration).attr('d', diagonal);

      // Transition exiting nodes to the parent's new position.
      link
        .exit()
        .transition()
        .duration(duration)
        .remove()
        .attr('d', (d) => {
          const o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        });

      // Stash the old positions for transition.
      root[direction].eachBefore((d) => {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }
    //画连接线
    function diagonal({ source, target }) {
      let s = source,
        d = target;
      return `M ${s.y} ${s.x} L ${(s.y + d.y) / 2} ${s.x}, L ${(s.y + d.y) / 2} ${
        d.x
      }, ${d.y} ${d.x}`;
    }
    // 画文本
    function drawText(id, dirRight) {
      dirRight = dirRight > 0; //右为1，左为-1
      return d3
        .select(`#${id}`)
        .append('text')
        .attr('y', textPadding)
        .attr('x', (d) => (dirRight ? textPadding : -textPadding))
        .attr('text-anchor', dirRight ? 'start' : 'end')
        .style('font-size', fontSize)
        .text((d) => d.data.name);
    }
    // 画子文本
    function drawTsText(id) {
      return d3
        .select(`#${id} text`)
        .append('tspan')
        .attr('fill', (d) => getTsTextColor(d.parent.data.name))
        .text((d) => d.data.value);
    }
    // 画方框阴影
    function drawFilter(id) {
      return d3
        .select(`#${id}`)
        .insert('defs', 'rect')
        .append('filter')
        .attr('id', `f${id}`)
        .attr('x', 0)
        .attr('y', 0)
        .append('feGaussianBlur')
        .attr('in', 'SourceGraphic')
        .attr('stdDeviation', '5');
    }
    // 画方框
    function drawRect(id, dirRight) {
      let realw = document.getElementById(id).getBBox().width + 10; //获取g实际宽度后，设置rect宽度
      return d3
        .select(`#${id}`)
        .insert('rect', 'text')
        .attr('x', dirRight > 0 ? 0 : -realw)
        .attr('y', -textSpace + textPadding)
        .attr('width', realw)
        .attr('height', textSpace + textPadding)
        .attr('rx', 2) //圆角
        .style('stroke', '#409eff')
        .style('fill', '#ffffff');
    }
    // 画circle
    function drawCircle(id) {
      let gMark = d3
        .select(`#${id}`)
        .append('g')
        .attr('class', 'node-circle')
        .attr('stroke', '#ffa500')
        .attr('stroke-width', 1);

      gMark
        .append('circle')
        .attr('fill', 'none')
        .attr('r', (d) => (d.depth === 0 ? 0 : circleR)) //根节点不设置圆圈
        .attr('fill', '#ffffff');
      let padding = circleR - 2;
      gMark.append('path').attr('d', `m -${padding} 0 l ${2 * padding} 0`); //横线

      gMark
        .append('path') //竖线，根据展开/收缩动态控制显示
        .attr('d', `m 0 -${padding} l 0 ${2 * padding}`)
        .attr('stroke-width', 0)
        .attr('class', 'node-circle-vertical');
      return gMark;
    }
    // 点击某个节点
    function clickNode(d, direction) {
      if (!d._children && !d.children) {
        navigateTo(d.data.id);
        // 无子节点
        return;
      }
      // 根据当前节点是否有children来判断是展开还是收缩，true收缩，false展开
      // tree会根据节点内是否有children来向下扩展
      d.children = d.children ? null : d._children;
      d3.select(`#g${d.id} .node-circle .node-circle-vertical`)
        .transition()
        .duration(duration)
        .attr('stroke-width', d.children ? 0 : 1); // 控制节点伸缩时的标识圆圈
      update(d, direction);
    }
    function getTsTextColor(name) {
      switch (name) {
        case '股东':
          return 'darkgray';
        case '供应商':
          return '#FF9800';
        case '合伙人':
          return 'green';
        default:
          return 'black';
      }
    }
    function getRectStorke(name) {
      switch (name) {
        case '征地规费':
          return 'green';
        case '市级层面文件':
          return 'skyblue';
        case '专项成本':
          return '#FF9800';
        default:
          return 'gray';
      }
    }
  </script>
</html>
